<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo阅读更多设置]]></title>
    <url>%2FHexo%2FHexo%E9%98%85%E8%AF%BB%E6%9B%B4%E5%A4%9A%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[关于在主页显示“阅读更多”在md需要截断的地方加入 1&lt;!--more--&gt;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1002. A+B for Polynomials (25)]]></title>
    <url>%2FPAT%2F%E7%94%B2%E7%BA%A7%2F1002%2F</url>
    <content type="text"><![CDATA[This time, you are supposed to find A+B where A and B are two polynomials. Input Specification:Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N1 aN1 N2 aN2 … NK aNK where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1, 2, ⋯, K) are the exponents and coefficients, respectively. It is given that 1 ≤ K ≤ 10，0 ≤ NK &lt; ⋯ &lt; N2 &lt; N1 ≤ 1000. Output Specification:For each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place. Sample Input:122 1 2.4 0 3.22 2 1.5 1 0.5 Sample Output:13 2 1.5 1 2.9 0 3.2 题目大意:计算2个多项式的和。 分析:A(x) = aN1 xN1 + aN2 xN2 + … 相同指数 N 的系数 aNx 相加即可。 C/C++:123456789101112131415161718192021#include &lt;cstdio&gt;int main()&#123; float a[1005] = &#123;0&#125;, temp; // 下标表示指数，存储系数 int k, n, cnt; int i = 2; while(i--)&#123; scanf("%d", &amp;k); while(k--)&#123; scanf("%d%f", &amp;n, &amp;temp); a[n] += temp; &#125; &#125; for(cnt = 0, i = 1000; i &gt;= 0; i--)&#123; if(a[i]) cnt++; &#125; printf("%d", cnt); for(i = 1000; i &gt;= 0; i--)&#123; if(a[i]) printf(" %d %.1f", i, a[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
        <category>甲级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1001. A+B Format (20)]]></title>
    <url>%2FPAT%2F%E7%94%B2%E7%BA%A7%2F1001%2F</url>
    <content type="text"><![CDATA[Calculate a+b and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless there are less than four digits). Input Specification:Each input file contains one test case. Each case contains a pair of integers a and b where −10^6 ≤ a, b ≤ 10^6. The numbers are separated by a space. Output Specification:For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format. Sample Input:1-1000000 9 Sample Output:1-999,991 题目大意:输出a+b的标准格式，也就是每隔3个数字1个逗号（,）。 分析:题目中限定了a+b的值最大是7位数，直接分3种情况输出，即2个逗号，1个逗号，0个逗号。 c/c++:1234567891011121314#include &lt;cstdio&gt;int main()&#123; int a, b, c; scanf("%d%d", &amp;a, &amp;b); c = a + b; if(c &lt; 0)&#123; printf("-"); c = -c; &#125; if(c &gt;= 1000000) printf("%d,%03d,%03d", c/1000000, c/1000%1000, c%1000); else if(c &gt;= 1000) printf("%d,%03d", c/1000, c%1000); else printf("%d", c); return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
        <category>甲级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1004. Counting Leaves (30)]]></title>
    <url>%2FPAT%2F%E7%94%B2%E7%BA%A7%2F1004%2F</url>
    <content type="text"><![CDATA[A family hierarchy is usually presented by a pedigree tree. Your job is to count those family members who have no child. Input Specification:Each input file contains one test case. Each case starts with a line containing 0 &lt; N &lt; 100, the number of nodes in a tree, and M (&lt; N), the number of non-leaf nodes. Then M lines follow, each in the format: 1ID K ID[1] ID[2] ... ID[K] where ID is a two-digit number representing a given non-leaf node, K is the number of its children, followed by a sequence of two-digit ID‘s of its children. For the sake of simplicity, let us fix the root ID to be 01. The input ends with N being 0. That case must NOT be processed. Output Specification:For each test case, you are supposed to count those family members who have no child for every seniority level starting from the root. The numbers must be printed in a line, separated by a space, and there must be no extra space at the end of each line. The sample case represents a tree with only 2 nodes, where 01 is the root and 02 is its only child. Hence on the root 01 level, there is 0 leaf node; and on the next level, there is 1 leaf node. Then we should output 0 1 in a line. Sample Input:122 101 1 02 Sample Output:10 1 题目大意:给一棵树，输出每层的叶子结点数。 分析:构建树，DFS，层序。 记录树的最大深度，每层的叶子结点数。 C/C++:123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; v[105];int levelNum[105] = &#123;0&#125;;int maxL = 0;void dfs(int cur, int depth)&#123; if(depth &gt; maxL) maxL = depth; if(v[cur].empty()) levelNum[depth]++; for(int i = 0; i &lt; v[cur].size(); i++)&#123; dfs(v[cur][i], depth + 1); &#125;&#125;int main()&#123; int n, m, node, k, c; scanf("%d%d", &amp;n, &amp;m); for(int i = 0; i &lt; m; i++)&#123; scanf("%d%d", &amp;node, &amp;k); while(k--)&#123; scanf("%d", &amp;c); v[node].push_back(c); &#125; &#125; dfs(1, 0); for(int i = 0; i &lt;= maxL; i++)&#123; printf("%d", levelNum[i]); if(i != maxL) printf(" "); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
        <category>甲级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1003. Emergency (25)]]></title>
    <url>%2FPAT%2F%E7%94%B2%E7%BA%A7%2F1003%2F</url>
    <content type="text"><![CDATA[As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible. Input Specification:Each input file contains one test case. For each test case, the first line contains 4 positive integers: N (≤500) - the number of cities (and the cities are numbered from 0 to N−1), M - the number of roads, C1 and C2 - the cities that you are currently in and that you must save, respectively. The next line contains N integers, where the i-th integer is the number of rescue teams in the i-th city. Then M lines follow, each describes a road with three integers c1, c2 and L, which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from C1 to C2. Output Specification:For each test case, print in one line two numbers: the number of different shortest paths between C1 and C2, and the maximum amount of rescue teams you can possibly gather. All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line. Sample Input:123456785 6 0 21 2 1 5 30 1 10 2 20 3 11 2 12 4 13 4 1 Sample Output:12 4 题目大意:给一张无向有权图，求出从当前点到指定点的最短路径数及最大权重。 分析:DFS，记录当前路径长度，当前权重，至终点时更新最短路径长度、路径数、最大权重。 C/C++:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;using namespace std;const int inf = 1e9;int n, m, src, dst;int w[505], g[505][505] = &#123;0&#125;;int num = 0;int minL = inf, curL = 0;int maxW = 0, curW = 0;bool visited[505] = &#123;false&#125;;void dfs(int v)&#123; if(v == dst)&#123; if(curL &lt; minL)&#123; num = 1; minL = curL; maxW = curW; &#125;else&#123; num++; if(curW &gt; maxW) maxW = curW; &#125; return; &#125; for(int i = 0; i &lt; n; i++)&#123; if(g[v][i] &amp;&amp; !visited[i])&#123; visited[i] = true; curL += g[v][i]; curW += w[i]; if(curL &lt;= minL) dfs(i); visited[i] = false; curL -= g[v][i]; curW -= w[i]; &#125; &#125;&#125;int main()&#123; scanf("%d%d%d%d", &amp;n, &amp;m, &amp;src, &amp;dst); for(int i = 0; i &lt; n; i++) scanf("%d", w + i); int c1, c2, l; while(m--)&#123; scanf("%d%d%d", &amp;c1, &amp;c2, &amp;l); g[c1][c2] = g[c2][c1] = l; &#125; visited[src] = true; curW = w[src]; dfs(src); printf("%d %d", num, maxW); return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
        <category>甲级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1005. Spell It Right (20)]]></title>
    <url>%2FPAT%2F%E7%94%B2%E7%BA%A7%2F1005%2F</url>
    <content type="text"><![CDATA[Given a non-negative integer N, your task is to compute the sum of all the digits of N, and output every digit of the sum in English. Input Specification:Each input file contains one test case. Each case occupies one line which contains an N (≤ 10100). Output Specification:For each test case, output in one line the digits of the sum in English words. There must be one space between two consecutive words, but no extra space at the end of a line. Sample Input:112345 Sample Output:1one five 题目大意:给一个数N，求出每位数字的和，输出和的每一位数字的拼音。 分析: string存N，处理每一位数字求和； 和转换成string； 输出和的每一位拼音。 c/c++:123456789101112131415#include &lt;iostream&gt;using namespace std;int main()&#123; int sum = 0; string inte; string number[10] = &#123;"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"&#125;; cin &gt;&gt; inte; for(int i = 0; i &lt; inte.size(); i++) sum += inte[i] - '0'; string ans = to_string(sum); for(int i = 0; i &lt; ans.size(); i++)&#123; cout &lt;&lt; number[ans[i] - '0']; if(i != ans.size()-1) cout &lt;&lt; " "; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
        <category>甲级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1014. Waiting in Line (30)]]></title>
    <url>%2FPAT%2F%E7%94%B2%E7%BA%A7%2F1014%2F</url>
    <content type="text"><![CDATA[Suppose a bank has N windows open for service. There is a yellow line in front of the windows which devides the waiting area into two parts. The rules for the customers to wait in line are: The space inside the yellow line in front of each window is enough to contain a line with M customers. Hence when all the N lines are full, all the customers after (and including) the (NM+1)st one will have to wait in a line behind the yellow line. Each customer will choose the shortest line to wait in when crossing the yellow line. If there are two or more lines with the same length, the customer will always choose the window with the smallest number. Customeri will take Ti minutes to have his/her transaction processed. The first N customers are assumed to be served at 8:00 am. Now given the processing time of each customer, you are supposed to tell the exact time at which a customer has his/her business done. For example, suppose that a bank has 2 windows and each window may have 2 customers waiting inside the yellow line. There are 5 customers waiting with transactions taking 1, 2, 6, 4 and 3 minutes, respectively. At 08:00 in the morning, customer1 is served at window1 while customer2 is served at window2. Customer3 will wait in front of window1 and customer4 will wait in front of window2. Customer5 will wait behind the yellow line. At 08:01, customer1 is done and customer5 enters the line in front of window1 since that line seems shorter now. Customer2 will leave at 08:02, customer4 at 08:06, customer3 at 08:07, and finally customer5 at 08:10. Input Specification:Each input file contains one test case. Each case starts with a line containing 4 positive integers: N(≤20, number of windows), M (≤10, the maximum capacity of each line inside the yellow line), K(≤1000, number of customers), and Q (≤1000, number of customer queries). The next line contains K positive integers, which are the processing time of the K customers. The last line contains Q positive integers, which represent the customers who are asking about the time they can have their transactions done. The customers are numbered from 1 to K. Output Specification:For each of the Q customers, print in one line the time at which his/her transaction is finished, in the format HH:MM where HH is in [08, 17] and MM is in [00, 59]. Note that since the bank is closed everyday after 17:00, for those customers who cannot be served before 17:00, you must output Sorry instead. Sample Input:1232 2 7 51 2 6 4 3 534 23 4 5 6 7 Sample Output:1234508:0708:0608:1017:00Sorry 题目大意: 一个银行有N个窗口，窗口前有一黄线把排队的客户分成2部分； 黄线里的部分每个窗口前可以排M个客户，黄线里的部分排满客户时其他客户排在黄线外； 每个客户在进入黄线后选最短的队，如果有多个最短的队，选数字最小的窗口； 8:00 开始服务，17:00 之后不再服务，但是已经在服务的服务完。 给定窗口数N，每个队最多的客户数M，每个客户的服务时间，查询的客户id，输出所查询的客户结束时间。 分析:用队列模拟。 在线处理即可，每输入一个客户的服务时间，模拟排队； 队列全满和有空队列分开来讨论： 队列全满时：遍历每个队列，找到队首最先结束的队列，pop队首，push当前客户； 有空队列时：找客户最少的队列，push当前客户进该队列； 根据队列最后一个客户的结束时间，记录这个客户的结束时间。 注意时间的记录，在 17:00 前开始的服务要输出时间，17:00 之后才能开始的服务应输出sorry。 注意:测试点0：有客户的开始时间在 17:00 的情况； 测试点2，5：有客户的结束时间再 17:00 之后的情况； 测试点4：所有队列都已经在 17:00 后服务结束，又来客户的情况。 C/C++:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int inf = 1e9;int n, m;int tm[1005];queue&lt;int&gt; line[25];void printTime(int t)&#123; if(t == inf) printf("Sorry\n"); else printf("%02d:%02d\n", 8 + t / 60, t % 60);&#125;int getWin()&#123; int win = -1, min = inf; for(int i = 0; i &lt; n; i++)&#123; if(line[i].size() &lt; m &amp;&amp; line[i].size() &lt; min)&#123; min = line[i].size(); win = i; &#125; &#125; if(win != -1) return win; for(int i = 0; i &lt; n; i++)&#123; if(tm[line[i].front()] &lt; min)&#123; min = tm[line[i].front()]; win = i; &#125; &#125; return win;&#125;int main()&#123; int k, q; scanf("%d%d%d%d", &amp;n, &amp;m, &amp;k, &amp;q); for(int i = 1; i &lt;= k; i++)&#123; int t, w; scanf("%d", &amp;t); w = getWin(); if(w == -1) tm[i] = inf; else if(line[w].empty()) tm[i] = t; else if(tm[line[w].back()] &gt;= 540) tm[i] = inf; else tm[i] = tm[line[w].back()] + t; if(line[w].size() == m) line[w].pop(); line[w].push(i); &#125; while(q--)&#123; int id; scanf("%d", &amp;id); printTime(tm[id]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
        <category>甲级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1018. Public Bike Management (30)]]></title>
    <url>%2FPAT%2F%E7%94%B2%E7%BA%A7%2F1018%2F</url>
    <content type="text"><![CDATA[There is a public bike service in Hangzhou City which provides great convenience to the tourists from all over the world. One may rent a bike at any station and return it to any other stations in the city. The Public Bike Management Center (PBMC) keeps monitoring the real-time capacity of all the stations. A station is said to be in perfect condition if it is exactly half-full. If a station is full or empty, PBMC will collect or send bikes to adjust the condition of that station to perfect. And more, all the stations on the way will be adjusted as well. When a problem station is reported, PBMC will always choose the shortest path to reach that station. If there are more than one shortest path, the one that requires the least number of bikes sent from PBMC will be chosen. The above figure illustrates an example. The stations are represented by vertices and the roads correspond to the edges. The number on an edge is the time taken to reach one end station from another. The number written inside a vertex S is the current number of bikes stored at S. Given that the maximum capacity of each station is 10. To solve the problem at S3, we have 2 different shortest paths: PBMC -&gt; S1 -&gt; S3. In this case, 4 bikes must be sent from PBMC, because we can collect 1 bike from S1 and then take 5 bikes to S3, so that both stations will be in perfect conditions. PBMC -&gt; S2 -&gt; S3. This path requires the same time as path 1, but only 3 bikes sent from PBMC and hence is the one that will be chosen. Input Specification:Each input file contains one test case. For each case, the first line contains 4 numbers: Cmax (≤100), always an even number, is the maximum capacity of each station; N (≤500), the total number of stations; Sp, the index of the problem station (the stations are numbered from 1 to N, and PBMC is represented by the vertex 0); and M, the number of roads. The second line contains N non-negative numbers Ci (i=1,⋯,N) where each Ci is the current number of bikes at Si respectively. Then M lines follow, each contains 3 numbers: Si, Sj, and Tij which describe the time Tij taken to move between stations Si and Sj. All the numbers in a line are separated by a space. Output Specification:For each test case, print your results in one line. First output the number of bikes that PBMC must send. Then after one space, output the path in the format: 0−&gt;S1−&gt;⋯−&gt;Sp. Finally after another space, output the number of bikes that we must take back to PBMC after the condition of Sp is adjusted to perfect. Note that if such a path is not unique, output the one that requires minimum number of bikes that we must take back to PBMC. The judge’s data guarantee that such a path is unique. Sample Input:123456710 3 3 56 7 00 1 10 2 10 3 31 3 12 3 1 Sample Output:13 0-&gt;2-&gt;3 0 题目大意:PMBC要让指定的Sp达到完美状态 从PMBC出发，遇到超过完美状态的，回收该点的车子；遇到不到完美状态的，如果手上有车子，就把手上的车子给他，如果不够就记录。 输出最短，需求最少，返回量最少的路径。 注意前面缺车子后面多车子的情况，不能把后面多的车子拿到前面。 分析:DFS，模拟 perfect = cmax / 2; 从0开始，need和back都为0，找下一个点； 如果这个点ci &lt; perfect： ​ back &gt;= perfect - ci ，back -= perfect - ci； ​ back &lt; perfect - ci，need += perfect - ci -back，back = 0； 如果这个点ci == perfect，不操作； 如果这个点ci &gt; perfect，back += ci - perfect。 DFS过程中记录路径长度，需求量，返回量。 C/C++:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int inf = 1e9;int perfect, n, sp, m;int c[505];int g[505][505] = &#123;0&#125;;bool visited[505] = &#123;true&#125;;vector&lt;int&gt; tPath, path;int len = 0, minLen = inf;int need = 0, back = 0;int minNeed = inf, minBack = inf;void dfs(int s)&#123; if(s == sp)&#123; if(len &lt; minLen)&#123; path = tPath; minLen = len; minNeed = need; minBack = back; &#125;else if(need &lt; minNeed || (need == minNeed &amp;&amp; back &lt; minBack))&#123; path = tPath; minNeed = need; minBack = back; &#125; return; &#125; for(int i = 1; i &lt;= n; i++)&#123; if(!visited[i] &amp;&amp; g[s][i])&#123; int tn = need, tb = back; if(c[i] &lt; perfect)&#123; if(back &gt;= perfect - c[i]) back -= perfect - c[i]; else&#123; need += perfect - c[i] -back; back = 0; &#125; &#125;else&#123; back += c[i] - perfect; &#125; visited[i] = true; len += g[s][i]; tPath.push_back(i); if(len &lt;= minLen) dfs(i); need = tn, back = tb; visited[i] = false; len -= g[s][i]; tPath.pop_back(); &#125; &#125;&#125;int main()&#123; scanf("%d%d%d%d", &amp;perfect, &amp;n, &amp;sp, &amp;m); perfect /= 2; for(int i = 1; i &lt;= n; i++) scanf("%d", c + i); for(int i = 0; i &lt; m; i++)&#123; int s1, s2, e; scanf("%d%d%d", &amp;s1, &amp;s2, &amp;e); g[s1][s2] = g[s2][s1] = e; &#125; dfs(0); printf("%d 0", minNeed); for(int i = 0; i &lt; path.size(); i++) printf("-&gt;%d", path[i]); printf(" %d", minBack); return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
        <category>甲级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1026. Table Tennis (30)]]></title>
    <url>%2FPAT%2F%E7%94%B2%E7%BA%A7%2F1026%2F</url>
    <content type="text"><![CDATA[A table tennis club has N tables available to the public. The tables are numbered from 1 to N. For any pair of players, if there are some tables open when they arrive, they will be assigned to the available table with the smallest number. If all the tables are occupied, they will have to wait in a queue. It is assumed that every pair of players can play for at most 2 hours. Your job is to count for everyone in queue their waiting time, and for each table the number of players it has served for the day. One thing that makes this procedure a bit complicated is that the club reserves some tables for their VIP members. When a VIP table is open, the first VIP pair in the queue will have the priviledge to take it. However, if there is no VIP in the queue, the next pair of players can take it. On the other hand, if when it is the turn of a VIP pair, yet no VIP table is available, they can be assigned as any ordinary players. Input Specification:Each input file contains one test case. For each case, the first line contains an integer N (≤10000) - the total number of pairs of players. Then N lines follow, each contains 2 times and a VIP tag: HH:MM:SS - the arriving time, P - the playing time in minutes of a pair of players, and tag - which is 1 if they hold a VIP card, or 0 if not. It is guaranteed that the arriving time is between 08:00:00 and 21:00:00 while the club is open. It is assumed that no two customers arrives at the same time. Following the players’ info, there are 2 positive integers: K (≤100) - the number of tables, and M (&lt; K) - the number of VIP tables. The last line contains M table numbers. Output Specification:For each test case, first print the arriving time, serving time and the waiting time for each pair of players in the format shown by the sample. Then print in a line the number of players served by each table. Notice that the output must be listed in chronological order of the serving time. The waiting time must be rounded up to an integer minute(s). If one cannot get a table before the closing time, their information must NOT be printed. Sample Input:123456789101112920:52:00 10 008:00:00 20 008:02:00 30 020:51:00 10 008:10:00 5 008:12:00 10 120:50:00 10 008:01:30 15 120:53:00 10 13 12 Sample Output:12345678908:00:00 08:00:00 008:01:30 08:01:30 008:02:00 08:02:00 008:12:00 08:16:30 508:10:00 08:20:00 1020:50:00 20:50:00 020:51:00 20:51:00 020:52:00 20:52:00 03 3 2 题目大意: 乒乓球俱乐部里有N张桌子，桌子有空着时，每当有玩家到来就能玩，否则要排队； 每对玩家最多玩2小时； 为VIP成员提供VIP桌，当空出VIP桌时，队列中的VIP成员可以优先使用，如果队伍里没VIP成员则给普通人用； 如果VIP在队首但是没有VIP桌子，用普通桌； 得在 21:00 之后才能开始玩的将无法服务。 输入到达时间、玩的时间、是否VIP，桌子数，VIP桌号； 按开始玩的顺序输出到达时间，开始玩的时间，等待时间；最后一行输出每张桌子的服务次数。 （根据提交代码AC的情况，貌似有下面这个隐含意思：有桌子空着时用最早结束的桌子，如果最早结束的桌子不唯一，用ID最小的桌子。） 分析:模拟，排序，队列 先接收数据（想玩超过2小时的，直接安排成2小时），按到达时间先后排序，作为排队队列，之后边模拟排队处理边输出。 如果队首不是VIP 如果有空桌子（即有结束时间 &lt;= 到达时间的桌子），安排上； 如果无空桌子，等待，找到结束时间最早的桌子： 如果最早的不是VIP桌，安排上； 如果最早的是VIP桌，看看队伍里这个时候有没有VIP玩家（即有到达时间 &lt;= 该桌子结束时间的VIP），有就给VIP使用，否则还是给队首使用； 如果队首是VIP 如果有空桌子，优先使用VIP桌，没有VIP桌的情况用普通桌； 如果无空桌子，等待，找到结束时间最早的桌子直接安排上； 每安排完一对玩家就输出该玩家的数据，更新桌子结束时间，从队列中删除该玩家。 注意:可服务时间为[8:00, 21:00) 测试点3：有个玩家 21:00 到达的情况。 C/C++:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int inf = 1e9;struct player&#123; int arrive; int play; bool vip;&#125;;struct tableNode&#123; int end = 8 * 3600; bool vip = false;&#125;table[105];int n, k;vector&lt;player&gt; players;bool cmp(player &amp;a, player &amp;b)&#123; return a.arrive &lt; b.arrive;&#125;int printData(int idx, int w)&#123; int t = players[idx].arrive; if(t + w &gt;= 21 * 3600) return 0; printf("%02d:%02d:%02d ", t / 3600, t % 3600 / 60, t % 60); t += w; printf("%02d:%02d:%02d ", t / 3600, t % 3600 / 60, t % 60); printf("%d\n", (w + 30) / 60); //四舍五入到分 return 1;&#125;int getTable()&#123; int index, min = inf; for(int i = 0; i &lt; k; i++)&#123; if(table[i].end &lt; min)&#123; min = table[i].end; index = i; &#125; &#125; return index;&#125;int getVIP(int t)&#123; for(int i = 0; i &lt; players.size() &amp;&amp; players[i].arrive &lt;= t; i++)&#123; if(players[i].vip) return i; &#125; return 0;&#125;int getVIPTable()&#123; int index, min = inf; for(int i = 0; i &lt; k; i++)&#123; if(table[i].end &lt; min &amp;&amp; table[i].vip)&#123; min = table[i].end; index = i; &#125; &#125; return index;&#125;int main()&#123; int t, hh, mm, ss, p, vip, m; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++)&#123; scanf("%d:%d:%d %d %d", &amp;hh, &amp;mm, &amp;ss, &amp;p, &amp;vip); t = hh * 3600 + mm * 60 + ss; p = p &gt; 120 ? 7200 : p * 60; players.push_back(player&#123;t, p, vip ? true : false&#125;); &#125; sort(players.begin(), players.end(), cmp); scanf("%d%d", &amp;k, &amp;m); while(m--)&#123; scanf("%d", &amp;vip); table[vip-1].vip = true; &#125; int cnt[105] = &#123;0&#125;, tb; while(!players.empty())&#123; tb = getTable(); if(table[tb].end &gt;= 21 * 3600) break; if(players[0].vip)&#123; if(table[tb].end &lt;= players[0].arrive)&#123; int vipTable = getVIPTable(); if(table[vipTable].end &lt;= players[0].arrive) tb = vipTable; cnt[tb] += printData(0, 0); table[tb].end = players[0].arrive + players[0].play; &#125;else&#123; cnt[tb] += printData(0, table[tb].end - players[0].arrive); table[tb].end += players[0].play; &#125; players.erase(players.begin()); &#125;else&#123; if(table[tb].end &lt;= players[0].arrive)&#123; cnt[tb] += printData(0, 0); table[tb].end = players[0].arrive + players[0].play; players.erase(players.begin()); &#125;else&#123; if(table[tb].vip)&#123; vip = getVIP(table[tb].end); cnt[tb] += printData(vip, table[tb].end - players[vip].arrive); table[tb].end += players[vip].play; players.erase(players.begin() + vip); &#125;else&#123; cnt[tb] += printData(0, table[tb].end - players[0].arrive); table[tb].end += players[0].play; players.erase(players.begin()); &#125; &#125; &#125; &#125; for(int i = 0; i &lt; k; i++)&#123; printf("%d", cnt[i]); if(i != k - 1) printf(" "); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
        <category>甲级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1034. Head of a Gang (30)]]></title>
    <url>%2FPAT%2F%E7%94%B2%E7%BA%A7%2F1034%2F</url>
    <content type="text"><![CDATA[One way that the police finds the head of a gang is to check people’s phone calls. If there is a phone call between A and B, we say that A and B is related. The weight of a relation is defined to be the total time length of all the phone calls made between the two persons. A “Gang” is a cluster of more than 2 persons who are related to each other with total relation weight being greater than a given threthold K. In each gang, the one with maximum total weight is the head. Now given a list of phone calls, you are supposed to find the gangs and the heads. Input Specification:Each input file contains one test case. For each case, the first line contains two positive numbers N and K (both less than or equal to 1000), the number of phone calls and the weight threthold, respectively. Then N lines follow, each in the following format: 1Name1 Name2 Time where Name1 and Name2 are the names of people at the two ends of the call, and Time is the length of the call. A name is a string of three capital letters chosen from A-Z. A time length is a positive integer which is no more than 1000 minutes. Output Specification:For each test case, first print in a line the total number of gangs. Then for each gang, print in a line the name of the head and the total number of the members. It is guaranteed that the head is unique for each gang. The output must be sorted according to the alphabetical order of the names of the heads. Sample Input 1:1234567898 59AAA BBB 10BBB AAA 20AAA CCC 40DDD EEE 5EEE DDD 70FFF GGG 30GGG HHH 20HHH FFF 10 Sample Output 1:1232AAA 3GGG 3 Sample Input 2:1234567898 70AAA BBB 10BBB AAA 20AAA CCC 40DDD EEE 5EEE DDD 70FFF GGG 30GGG HHH 20HHH FFF 10 Sample Output 2:10 题目大意:给顶点和带权重的边，有边相连的点构成一个集合，人数大于2且集合的边权和大于给定值K的集合成为Gang。 每个点的权重可以理解为该点的边权和。 输出Gang的总数，每个Gang的老大（权重最大的点），人数；按老大名字的字母序输出。 分析:输入的时候就可以计算出每个点的权重，用 map&lt;string, int&gt; 存储； 边用 &lt;map, set\&gt; 存储，理解为每个点所连接的点。 每次循环： 以没遍历过的点为起点，DFS，遍历每个点并标记，记录边权和，记录人数，顺便找出权重最大的点为老大。为一趟遍历。 该集合的边权和 = 各点权重和 / 2。 边权和大于给定值K，则把老大和人数存放至结果数组。 ​ C/C++:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;map&lt;string, set&lt;string&gt;&gt; g;map&lt;string, int&gt; w;map&lt;string, bool&gt; visited;int num;string head;int total;struct node&#123; string head; int num; bool operator &lt; (const node a) const&#123; return head &lt; a.head; &#125;&#125;;void dfs(string &amp;v)&#123; visited[v] = true; num++; total += w[v]; if(w[head] &lt; w[v])&#123; head = v; &#125; for(auto it : g[v])&#123; if(!visited[it]) dfs(it); &#125;&#125;int main()&#123; int n, k, ew; string a, b; scanf("%d%d", &amp;n, &amp;k); while(n--)&#123; cin &gt;&gt; a &gt;&gt; b; scanf("%d", &amp;ew); w[a] += ew; w[b] += ew; g[a].insert(b); g[b].insert(a); &#125; set&lt;node&gt; ans; for(auto it : g)&#123; if(!visited[it.first])&#123; num = 0; total = 0; head = it.first; dfs(head); if(num &gt; 2 &amp;&amp; total / 2 &gt; k)&#123; ans.insert(node&#123;head, num&#125;); &#125; &#125; &#125; printf("%d\n", ans.size()); for(auto it : ans)&#123; cout &lt;&lt; it.head + " " &lt;&lt; it.num &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
        <category>甲级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1038. Recover the Smallest Number (30)]]></title>
    <url>%2FPAT%2F%E7%94%B2%E7%BA%A7%2F1038%2F</url>
    <content type="text"><![CDATA[Given a collection of number segments, you are supposed to recover the smallest number from them. For example, given { 32, 321, 3214, 0229, 87 }, we can recover many numbers such like 32-321-3214-0229-87 or 0229-32-87-321-3214 with respect to different orders of combinations of these segments, and the smallest number is 0229-321-3214-32-87. Input Specification:Each input file contains one test case. Each case gives a positive integer N (≤104) followed by Nnumber segments. Each segment contains a non-negative integer of no more than 8 digits. All the numbers in a line are separated by a space. Output Specification:For each test case, print the smallest number in one line. Notice that the first digit must not be zero. Sample Input:15 32 321 3214 0229 87 Sample Output:122932132143287 题目大意:给一串数字，输出能组成的最大数。 分析:针对任意2个数字a和b，若 a + b 值比 b + a 大，则 a 一定在 b 前。 用sort排序。 注意:测试点2：结果为0 C/C++123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;bool cmp(string &amp;a, string &amp;b)&#123; return a + b &lt; b + a;&#125;int main()&#123; int n; string s[10005], r; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; s[i]; &#125; sort(s, s+n, cmp); for(int i=0; i&lt;n; i++)&#123; r += s[i]; &#125; while(r[0] == '0')&#123; r.erase(r.begin()); &#125; if(r.size() == 0) cout &lt;&lt; 0; else cout &lt;&lt; r; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
        <category>甲级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1030. Travel Plan (30)]]></title>
    <url>%2FPAT%2F%E7%94%B2%E7%BA%A7%2F1030%2F</url>
    <content type="text"><![CDATA[A traveler’s map gives the distances between cities along the highways, together with the cost of each highway. Now you are supposed to write a program to help a traveler to decide the shortest path between his/her starting city and the destination. If such a shortest path is not unique, you are supposed to output the one with the minimum cost, which is guaranteed to be unique. Input Specification:Each input file contains one test case. Each case starts with a line containing 4 positive integers N, M, S, and D, where N (≤500) is the number of cities (and hence the cities are numbered from 0 to N−1); M is the number of highways; S and D are the starting and the destination cities, respectively. Then M lines follow, each provides the information of a highway, in the format: 1City1 City2 Distance Cost where the numbers are all integers no more than 500, and are separated by a space. Output Specification:For each test case, print in one line the cities along the shortest path from the starting point to the destination, followed by the total distance and the total cost of the path. The numbers must be separated by a space and there must be no extra space at the end of output. Sample Input:1234564 5 0 30 1 1 201 3 2 300 3 4 100 2 2 202 3 1 20 Sample Output:10 2 3 3 40 题目大意:给一张无向有权图，找到从起点到终点最短路径，如果不唯一，那就花费最少的。 输出最短路径，总距离，总权重。 分析:DFS，记录路径长度，边权和，最短路径长度，当前路径边权和。 C/C++:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int inf = 1e9;int n, m, s, d;bool visit[505] = &#123;false&#125;;int g[505][505] = &#123;0&#125;;int c[505][505] = &#123;0&#125;;int dist, minDist = inf;int cost, minCost = inf;vector&lt;int&gt; tPath, path;void dfs(int v)&#123; if(v == d)&#123; if(dist &lt; minDist || (dist == minDist &amp;&amp; cost &lt; minCost))&#123; minDist = dist; minCost = cost; path = tPath; &#125; return; &#125; for(int i = 0; i &lt; n; i++)&#123; if(g[v][i] &amp;&amp; !visit[i])&#123; visit[i] = true; tPath.push_back(i); dist += g[v][i]; cost += c[v][i]; if(dist &lt;= minDist) dfs(i); dist -= g[v][i]; cost -= c[v][i]; visit[i] = false; tPath.pop_back(); &#125; &#125;&#125;int main()&#123; scanf("%d%d%d%d", &amp;n, &amp;m, &amp;s, &amp;d); int a, b, dist, cost; for(int i=0; i&lt;m; i++)&#123; scanf("%d%d%d%d", &amp;a, &amp;b, &amp;dist, &amp;cost); g[a][b] = g[b][a] = dist; c[a][b] = c[b][a] = cost; &#125; visit[s] = true; tPath.push_back(s); dfs(s); for(int i = 0; i &lt; path.size(); i++) printf("%d ", path[i]); printf("%d %d", minDist, minCost); return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
        <category>甲级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1140. Look-and-say Sequence (20)]]></title>
    <url>%2FPAT%2F%E7%94%B2%E7%BA%A7%2F1040%2F</url>
    <content type="text"><![CDATA[Look-and-say sequence is a sequence of integers as the following: 1D, D1, D111, D113, D11231, D112213111, ... where D is in [0, 9] except 1. The (n+1)st number is a kind of description of the nth number. For example, the 2nd number means that there is one D in the 1st number, and hence it is D1; the 2nd number consists of one D (corresponding to D1) and one 1 (corresponding to 11), therefore the 3rd number is D111; or since the 4th number is D113, it consists of one D, two 1’s, and one 3, so the next number must be D11231. This definition works for D = 1 as well. Now you are supposed to calculate the Nth number in a look-and-say sequence of a given digit D. Input Specification:Each input file contains one test case, which gives D (in [0, 9]) and a positive integer N (≤ 40), separated by a space. Output Specification:Print in a line the Nth number in a look-and-say sequence of D. Sample Input:11 8 Sample Output:11123123111 题目大意:先给个起始字符串，然后根据当前字符串读出下一个字符串。 比如对D11231这个字符串，D有1个，1有2个，2有1个，3有1个，1有1个，于是得到D112213111。 分析:没啥好分析的，就那么操作呗 C/C++:12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int main()&#123; int n; string s, t; cin &gt;&gt; s &gt;&gt; n; for(int j = 1; j &lt; n; j++)&#123; t = ""; int cnt = 1; for(int i = 1; i &lt; s.size(); i++)&#123; if(s[i] == s[i-1]) cnt++; else&#123; t += s[i-1] + to_string(cnt); cnt = 1; &#125; &#125; t += s.back() + to_string(cnt); s = t; &#125; cout &lt;&lt; s; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
        <category>甲级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1022. Digital Library (30)]]></title>
    <url>%2FPAT%2F%E7%94%B2%E7%BA%A7%2F1022%2F</url>
    <content type="text"><![CDATA[A Digital Library contains millions of books, stored according to their titles, authors, key words of their abstracts, publishers, and published years. Each book is assigned an unique 7-digit number as its ID. Given any query from a reader, you are supposed to output the resulting books, sorted in increasing order of their ID’s. Input Specification:Each input file contains one test case. For each case, the first line contains a positive integer N (≤104) which is the total number of books. Then N blocks follow, each contains the information of a book in 6 lines: Line #1: the 7-digit ID number; Line #2: the book title – a string of no more than 80 characters; Line #3: the author – a string of no more than 80 characters; Line #4: the key words – each word is a string of no more than 10 characters without any white space, and the keywords are separated by exactly one space; Line #5: the publisher – a string of no more than 80 characters; Line #6: the published year – a 4-digit number which is in the range [1000, 3000]. It is assumed that each book belongs to one author only, and contains no more than 5 key words; there are no more than 1000 distinct key words in total; and there are no more than 1000 distinct publishers. After the book information, there is a line containing a positive integer M (≤1000) which is the number of user’s search queries. Then M lines follow, each in one of the formats shown below: 1: a book title 2: name of an author 3: a key word 4: name of a publisher 5: a 4-digit number representing the year Output Specification:For each query, first print the original query in a line, then output the resulting book ID’s in increasing order, each occupying a line. If no book is found, print Not Found instead. Sample Input:123456789101112131415161718192021222324252631111111The Testing BookYue Chentest code debug sort keywordsZUCS Print20113333333Another Testing BookYue Chentest code sort keywordsZUCS Print220122222222The Testing BookCYLLkeywords debug bookZUCS Print2201161: The Testing Book2: Yue Chen3: keywords4: ZUCS Print5: 20113: blablabla Sample Output:12345678910111213141516171: The Testing Book111111122222222: Yue Chen111111133333333: keywords1111111222222233333334: ZUCS Print11111115: 2011111111122222223: blablablaNot Found 题目大意:输入书的ID、标题、作者、关键字、发行商、年份信息，针对不同的查询方式按升序输出书的ID。 分析:用map和set，存储各种书的属性映射到书的ID的集合。 C/C++:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;map&lt;string, set&lt;int&gt;&gt; title, author, key, pub, year;void query(map&lt;string, set&lt;int&gt;&gt; &amp;m, string &amp;str)&#123; if(m.find(str) != m.end())&#123; for(auto it = m[str].begin(); it != m[str].end(); it++)&#123; printf("%07d\n", *it); &#125; &#125; else printf("Not Found\n");&#125;int main()&#123; int n, m, id; string ttitle, tauthor, tkey, tpub, tyear; scanf("%d", &amp;n); while(n--)&#123; scanf("%d\n", &amp;id); getline(cin, ttitle); title[ttitle].insert(id); getline(cin, tauthor); author[tauthor].insert(id); while(cin &gt;&gt; tkey)&#123; key[tkey].insert(id); if(getchar() == '\n') break; &#125; getline(cin, tpub); pub[tpub].insert(id); getline(cin, tyear); year[tyear].insert(id); &#125; scanf("%d", &amp;m); int index; string str; while(m--)&#123; scanf("%d: ", &amp;index); getline(cin, str); printf("%d: ", index); cout &lt;&lt; str &lt;&lt; endl; if(index == 1) query(title, str); else if(index == 2) query(author, str); else if(index == 3) query(key, str); else if(index == 4) query(pub, str); else if(index == 5) query(year, str); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
        <category>甲级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1146. Topological Order (25)]]></title>
    <url>%2FPAT%2F%E7%94%B2%E7%BA%A7%2F1146%2F</url>
    <content type="text"><![CDATA[This is a problem given in the Graduate Entrance Exam in 2018: Which of the following is NOT a topological order obtained from the given directed graph? Now you are supposed to write a program to test each of the options. Input Specification:Each input file contains one test case. For each case, the first line gives two positive integers N (≤1,000), the number of vertices in the graph, and M (≤ 10,000), the number of directed edges. Then M lines follow, each gives the start and the end vertices of an edge. The vertices are numbered from 1 to N. After the graph, there is another positive integer K (≤ 100). Then K lines of query follow, each gives a permutation of all the vertices. All the numbers in a line are separated by a space. Output Specification:Print in a line all the indices of queries which correspond to “NOT a topological order”. The indices start from zero. All the numbers are separated by a space, and there must no extra space at the beginning or the end of the line. It is graranteed that there is at least one answer. Sample Input:1234567891011121314156 81 21 35 25 42 32 63 46 451 5 2 3 6 45 1 2 6 3 45 1 2 3 6 45 2 1 6 3 41 2 3 4 5 6 Sample Output:13 4 题目大意:给一张有向图，判断给的序列是否是其可能的拓扑序列，输出不是的序列的序号。 分析:可以用二维数组来存边，v[v1] 这个数组里存有 v1 指向的点，in数组存有入度，每次读取一个点，若该点入度不为0则不是托扑序列，否则这个点所指向的点入度 - 1。 C/C++:12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123; int n, m, k, v1, v2; int in[1005]; vector&lt;int&gt; v[1005]; scanf("%d%d", &amp;n, &amp;m); for(int i = 0; i &lt; m; i++)&#123; scanf("%d%d", &amp;v1, &amp;v2); v[v1].push_back(v2); in[v2]++; &#125; vector&lt;int&gt; ans; scanf("%d", &amp;k); for(int i = 0; i &lt; k; i++)&#123; vector&lt;int&gt; tin(in, in + n + 1); bool isAns = true; for(int j = 0; j &lt; n; j++)&#123; scanf("%d", &amp;v1); if(tin[v1]) isAns = false; for(int it : v[v1]) tin[it]--; &#125; if(!isAns) ans.push_back(i); &#125; for(int i = 0; i &lt; ans.size(); i++)&#123; printf("%d", ans[i]); if(i != ans.size() - 1) printf(" "); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
        <category>甲级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1141. PAT Ranking of Institutions (25)]]></title>
    <url>%2FPAT%2F%E7%94%B2%E7%BA%A7%2F1141%2F</url>
    <content type="text"><![CDATA[After each PAT, the PAT Center will announce the ranking of institutions based on their students’ performances. Now you are asked to generate the ranklist. Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤105), which is the number of testees. Then N lines follow, each gives the information of a testee in the following format: 1ID Score School where ID is a string of 6 characters with the first one representing the test level: B stands for the basic level, A the advanced level and T the top level; Score is an integer in [0, 100]; and Schoolis the institution code which is a string of no more than 6 English letters (case insensitive). Note: it is guaranteed that ID is unique for each testee. Output Specification:For each case, first print in a line the total number of institutions. Then output the ranklist of institutions in nondecreasing order of their ranks in the following format: 1Rank School TWS Ns where Rank is the rank (start from 1) of the institution; School is the institution code (all in lower case); ; TWS is the total weighted score which is defined to be the integer part of ScoreB/1.5 + ScoreA + ScoreT*1.5, where ScoreX is the total score of the testees belong to this institution on level X; and Ns is the total number of testees who belong to this institution. The institutions are ranked according to their TWS. If there is a tie, the institutions are supposed to have the same rank, and they shall be printed in ascending order of Ns. If there is still a tie, they shall be printed in alphabetical order of their codes. Sample Input:123456789101110A57908 85 AuB57908 54 LanXA37487 60 auT28374 67 CMUT32486 24 hypuA66734 92 cmuB76378 71 AUA47780 45 lanxA72809 100 pkuA03274 45 hypu Sample Output:12345651 cmu 192 21 au 192 33 pku 100 14 hypu 81 24 lanx 81 2 题目大意:给各学校的PAT做题情况，统计总分后按排名输出； 学校名字大小写不敏感，全部用小写存储输出； T级按1.5倍算分，A级1倍算分，B级1/1.5倍算分； 输出排名信息，相同总分的学校排名相同，人数少的在前，人数相同的情况下，按名字字母序。 分析:map&lt;string, int&gt; 把学校id映射到数据数组下标； 注意:测试点5： tws 全程都用int存导致错误，中间数据用double存。 C/C++:1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;map&lt;string, double&gt; tws;map&lt;string, int&gt; ns;struct node&#123; string school; int tws; int ns;&#125;;bool cmp(node &amp;a, node &amp;b)&#123; if(a.tws != b.tws) return a.tws &gt; b.tws; else if(a.ns != b.ns) return a.ns &lt; b.ns; else return a.school &lt; b.school;&#125;int main()&#123; int n, score; string id, school; scanf("%d", &amp;n); while(n--)&#123; cin &gt;&gt; id &gt;&gt; score &gt;&gt; school; for(int i = 0; i &lt; school.size(); i++) school[i] = tolower(school[i]); if(id[0] == 'A') tws[school] += score; else if(id[0] == 'B') tws[school] += score / 1.5; else tws[school] += score * 1.5; ns[school]++; &#125; printf("%d\n", tws.size()); vector&lt;node&gt; ans; for(auto it : tws)&#123; ans.push_back(node&#123;it.first, it.second, ns[it.first]&#125;); &#125; sort(ans.begin(), ans.end(), cmp); int rank = 0; for(int i = 0; i &lt; ans.size(); i++)&#123; if(i == 0 || ans[i].tws &lt; ans[i-1].tws) rank = i + 1; printf("%d ", rank); cout &lt;&lt; ans[i].school; printf(" %d %d\n", ans[i].tws, ans[i].ns); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
        <category>甲级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1147. Heaps (30)]]></title>
    <url>%2FPAT%2F%E7%94%B2%E7%BA%A7%2F1147%2F</url>
    <content type="text"><![CDATA[In computer science, a heap is a specialized tree-based data structure that satisfies the heap property: if P is a parent node of C, then the key (the value) of P is either greater than or equal to (in a max heap) or less than or equal to (in a min heap) the key of C. A common implementation of a heap is the binary heap, in which the tree is a complete binary tree. (Quoted from Wikipedia at https://en.wikipedia.org/wiki/Heap_(data_structure)) Your job is to tell if a given complete binary tree is a heap. Input Specification:Each input file contains one test case. For each case, the first line gives two positive integers: M (≤ 100), the number of trees to be tested; and N (1 &lt; N ≤ 1,000), the number of keys in each tree, respectively. Then M lines follow, each contains N distinct integer keys (all in the range of int), which gives the level order traversal sequence of a complete binary tree. Output Specification:For each given tree, print in a line Max Heap if it is a max heap, or Min Heapfor a min heap, or Not Heap if it is not a heap at all. Then in the next line print the tree’s postorder traversal sequence. All the numbers are separated by a space, and there must no extra space at the beginning or the end of the line. Sample Input:12343 898 72 86 60 65 12 23 508 38 25 58 52 82 70 6010 28 15 12 34 9 8 56 Sample Output:123456Max Heap50 60 65 72 12 23 86 98Min Heap60 58 52 38 82 70 25 8Not Heap56 12 34 28 9 8 15 10 题目大意:给一个堆，判断是最大堆还是最小堆，并输出后序遍历结果。 分析:dfs，一边后序遍历，一边判断是否是最大堆、最小堆即可。 C/C++:123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int m, n;int v[1005];bool isMax, isMin;vector&lt;int&gt; post;void dfs(int cur)&#123; int left = cur * 2, right = left + 1; if(left &lt;= n)&#123; if(v[cur] &lt; v[left]) isMax = false; if(v[cur] &gt; v[left]) isMin = false; dfs(left); &#125; if(right &lt;= n)&#123; if(v[cur] &lt; v[right]) isMax = false; if(v[cur] &gt; v[right]) isMin = false; dfs(right); &#125; post.push_back(v[cur]);&#125;int main()&#123; scanf("%d%d", &amp;m, &amp;n); while(m--)&#123; isMax = isMin = true; post.clear(); for(int i = 1; i &lt;= n; i++) scanf("%d", v + i); dfs(1); if(isMax) printf("Max Heap\n"); else if(isMin) printf("Min Heap\n"); else printf("Not Heap\n"); for(int i = 0; i &lt; n; i++)&#123; printf("%d", post[i]); if(i != n - 1) printf(" "); &#125; printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
        <category>甲级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1143. Lowest Common Ancestor (30)]]></title>
    <url>%2FPAT%2F%E7%94%B2%E7%BA%A7%2F1143%2F</url>
    <content type="text"><![CDATA[The lowest common ancestor (LCA) of two nodes U and V in a tree is the deepest node that has both U and V as descendants. A binary search tree (BST) is recursively defined as a binary tree which has the following properties: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than or equal to the node’s key. Both the left and right subtrees must also be binary search trees. Given any two nodes in a BST, you are supposed to find their LCA. Input Specification:Each input file contains one test case. For each case, the first line gives two positive integers: M (≤ 1,000), the number of pairs of nodes to be tested; and N (≤ 10,000), the number of keys in the BST, respectively. In the second line, N distinct integers are given as the preorder traversal sequence of the BST. Then M lines follow, each contains a pair of integer keys U and V. All the keys are in the range of int. Output Specification:For each given pair of U and V, print in a line LCA of U and V is A. if the LCA is found and A is the key. But if A is one of U and V, print X is an ancestor of Y. where X is A and Y is the other node. If U or V is not found in the BST, print in a line ERROR: U is not found. or ERROR: V is not found. or ERROR: U and V are not found.. Sample Input:123456786 86 3 1 2 5 4 8 72 58 71 912 -30 899 99 Sample Output:123456LCA of 2 and 5 is 3.8 is an ancestor of 7.ERROR: 9 is not found.ERROR: 12 and -3 are not found.ERROR: 0 is not found.ERROR: 99 and 99 are not found. 题目大意:给BST的先序遍历结果，找2个点的最低公共祖先。 分析:根据BST的性质，最低公共祖先的大小一定在这2个值中间，遍历一边数组找到即可。 C/C++:123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;map&lt;int, int&gt; idx;int a[10005];int main()&#123; int m, n, v1, v2; scanf("%d%d", &amp;m, &amp;n); for(int i = 1; i &lt;= n; i++)&#123; scanf("%d", a + i); idx[a[i]] = i; &#125; while(m--)&#123; scanf("%d%d", &amp;v1, &amp;v2); if(idx[v1] + idx[v2] == 0) printf("ERROR: %d and %d are not found.\n", v1, v2); else if(idx[v1] == 0) printf("ERROR: %d is not found.\n", v1); else if(idx[v2] == 0) printf("ERROR: %d is not found.\n", v2); else&#123; int an; for(int i = 1; i &lt;= n; i++)&#123; an = a[i]; if(an &lt;= v1 &amp;&amp; an &gt;= v2 || an &gt;= v1 &amp;&amp; an &lt;= v2) break; &#125; if(an == v1) printf("%d is an ancestor of %d.\n", v1, v2); else if(an == v2) printf("%d is an ancestor of %d.\n", v2, v1); else printf("LCA of %d and %d is %d.\n", v1, v2, an); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
        <category>甲级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1148. Werewolf - Simple Version (20)]]></title>
    <url>%2FPAT%2F%E7%94%B2%E7%BA%A7%2F1148%2F</url>
    <content type="text"><![CDATA[Werewolf（狼人杀） is a game in which the players are partitioned into two parties: the werewolves and the human beings. Suppose that in a game, player #1 said: “Player #2 is a werewolf.”; player #2 said: “Player #3 is a human.”; player #3 said: “Player #4 is a werewolf.”; player #4 said: “Player #5 is a human.”; and player #5 said: “Player #4 is a human.”. Given that there were 2 werewolves among them, at least one but not all the werewolves were lying, and there were exactly 2 liars. Can you point out the werewolves? Now you are asked to solve a harder version of this problem: given that there were N players, with 2 werewolves among them, at least one but not all the werewolves were lying, and there were exactly 2 liars. You are supposed to point out the werewolves. Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (5≤N≤100). Then N lines follow and the i-th line gives the statement of the i-th player (1≤i≤N), which is represented by the index of the player with a positive sign for a human and a negative sign for a werewolf. Output Specification:If a solution exists, print in a line in ascending order the indices of the two werewolves. The numbers must be separated by exactly one space with no extra spaces at the beginning or the end of the line. If there are more than one solution, you must output the smallest solution sequence – that is, for two sequences A=a[1],…,a[M] and B=b[1],…,b[M], if there exists 0≤k&lt;M such that a[i]=b[i] (i≤k) and a[k+1]&lt;b[k+1], then A is said to be smaller than B. In case there is no solution, simply print No Solution. Sample Input 1:1234565-2+3-4+5+4 Sample Output 1:11 4 Sample Input 2:12345676+6+3+1-5-2+4 Sample Output 2 (the solution is not unique):11 5 Sample Input 3:1234565-2-3-4-5-1 Sample Output 3:1No Solution 题目大意:一堆人玩狼人杀，有2个狼人，一个狼人在撒谎，一个人类在撒谎，找出狼人 先给出人数N，然后给出第i个人的观点，正号代表人类，负号代表狼人 如存在多种情况则给出序列最小的情况，不存在则输出No Solution 分析:因为题目中最大的人数才100，可以暴力，假设撒谎的2人，然后判断是否符合要求。 可以这样： 取2人撒谎 分配每个人的身份 若狼人多于2个，冲突；否则从未知的人中从小的下标来填充狼人至2个 判断狼人中是否只有一个在说谎 若只有一个说谎，则和之前记录的狼人比较，记录小的序列 C/C++:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int n, said[105];int w1 = 105, w2 = 105; // 记录2个狼人void solve(int l1, int l2) &#123; int status[105] = &#123;0&#125;; // 记录每个人的身份，0未知，1人类，2狼人 vector&lt;int&gt; wolves; for (int i = 1; i &lt;= n; i++) &#123; // 分配身份 if (said[i] &lt; 0) &#123; int j = -said[i]; // i说j是狼人 if (status[j] == 1) return; // j已经是人类了 else status[j] = 2; &#125; else &#123; int j = said[i]; if(status[j] == 2) return; else status[j] = 1; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; // 找到可以肯定的狼人 if (status[i] == 2) wolves.push_back(i); &#125; if (wolves.size() &gt; 2) return; // 狼人数量大于2个 for (int i = 1; i &lt;= n &amp;&amp; wolves.size() &lt; 2; i++)&#123; // 使狼人数量到达2个 if (status[i] == 0) wolves.push_back(i); &#125; if (wolves.size() &lt; 2) return; // 无法找到2个狼人 if (wolves[0] &gt; wolves[1]) swap(wolves[0], wolves[1]); if ((wolves[0] == l1) + (wolves[0] == l2) + (wolves[1] == l1) + (wolves[1] == l2) == 1) &#123;// 狼人中只有一个说谎 if (wolves[0] &lt; w1 || (wolves[0] == w1 &amp;&amp; wolves[1] &lt; w2)) &#123; // 找到更小的序列 w1 = wolves[0]; w2 = wolves[1]; &#125; &#125;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", said + i); for (int i = 1; i &lt;= n; i++) &#123; said[i] = -said[i]; // i说谎 for (int j = i + 1; j &lt;= n; j++) &#123; said[j] = -said[j]; // j说谎 solve(i, j); said[j] = -said[j]; &#125; said[i] = -said[i]; &#125; if (w2 != 105) printf("%d %d", w1, w2); else printf("No Solution"); return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
        <category>甲级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1151. LCA in a Binary Tree (30)]]></title>
    <url>%2FPAT%2F%E7%94%B2%E7%BA%A7%2F1151%2F</url>
    <content type="text"><![CDATA[The lowest common ancestor (LCA) of two nodes U and V in a tree is the deepest node that has both U and V as descendants. Given any two nodes in a binary tree, you are supposed to find their LCA. Input Specification:Each input file contains one test case. For each case, the first line gives two positive integers: M (≤ 1,000), the number of pairs of nodes to be tested; and N (≤ 10,000), the number of keys in the binary tree, respectively. In each of the following two lines, N distinct integers are given as the inorder and preorder traversal sequences of the binary tree, respectively. It is guaranteed that the binary tree can be uniquely determined by the input sequences. Then M lines follow, each contains a pair of integer keys U and V. All the keys are in the range of int. Output Specification:For each given pair of U and V, print in a line LCA of U and V is A. if the LCA is found and A is the key. But if A is one of U and V, print X is an ancestor of Y. where X is A and Y is the other node. If U or V is not found in the binary tree, print in a line ERROR: U is not found. or ERROR: V is not found.or ERROR: U and V are not found.. Sample Input:1234567896 87 2 3 4 6 5 1 85 3 7 2 6 4 8 12 68 17 912 -30 899 99 Sample Output:123456LCA of 2 and 6 is 3.8 is an ancestor of 1.ERROR: 9 is not found.ERROR: 12 and -3 are not found.ERROR: 0 is not found.ERROR: 99 and 99 are not found. 题目大意:给定一棵树的中序遍历和先序遍历结果，问2个结点的最近公共祖先结点 分析:对2个结点，在中序遍历时，最近公共祖先结点是在这两个结点之间的，因此可以这么做： 根据先序遍历结果找到这课树的根结点，如果根结点 = u(v)，则 u(v) 就是 v(u) 的祖先，否则继续判断 在中序遍历中找到根结点的位置，判断 u 和 v 是否在根的两边，如果在两边则这个根就是最近公共子结点；若不在两边，则继续判断 若 u 和 v 都在根左边，则对左子树进行从 1 开始的操作，若在右边则对右子树进行操作 针对题目要求，可以记录每个值所在中序遍历结果的下标，从 1 开始，便于判断这个点是否存在这颗树中，也可以方便寻找根结点在中序结果中的位置 C++:12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;int u, v;int in[10005], pre[10005];map&lt;int, int&gt; p; // 记录点在 in 中的位置int pu, pv;void dfs(int p1, int p2, int m) &#123; // p1 是这颗树在先序结果中的起点，p2 是在中序遍历中的起点，m 是这颗树的大小 int proot = p[pre[p2]]; // 找到这颗树在 in 中的位置 if (pu == proot) printf("%d is an ancestor of %d.\n", u, v); else if (pv == proot) printf("%d is an ancestor of %d.\n", v, u); else if ((proot - pv) * (proot - pu) &lt; 0) printf("LCA of %d and %d is %d.\n", u, v, in[proot]); else if (pu &lt; proot &amp;&amp; pv &lt; proot) dfs(p1, p2 + 1, proot - p1); // 遍历左子树 else dfs(proot + 1, p2 + 1, m - proot);&#125;int main() &#123; int m, n; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d", in + i); p[in[i]] = i; &#125; for (int i = 1; i &lt;= m; i++) scanf("%d", pre + i); while (n--) &#123; scanf("%d%d", &amp;u, &amp;v); pu = p[u]; pv = p[v]; if (pu + pv == 0) printf("ERROR: %d and %d are not found.\n", u, v); else if (pu == 0) printf("ERROR: %d is not found.\n", u); else if (pv == 0) printf("ERROR: %d is not found.\n", v); else dfs(1, 1, m); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
        <category>甲级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1149. Dangerous Goods Packaging (25)]]></title>
    <url>%2FPAT%2F%E7%94%B2%E7%BA%A7%2F1149%2F</url>
    <content type="text"><![CDATA[When shipping goods with containers, we have to be careful not to pack some incompatible goods into the same container, or we might get ourselves in serious trouble. For example, oxidizing agent （氧化剂） must not be packed with flammable liquid （易燃液体）, or it can cause explosion. Now you are given a long list of incompatible goods, and several lists of goods to be shipped. You are supposed to tell if all the goods in a list can be packed into the same container. Input Specification:Each input file contains one test case. For each case, the first line gives two positive integers: N (≤104), the number of pairs of incompatible goods, and M(≤100), the number of lists of goods to be shipped. Then two blocks follow. The first block contains N pairs of incompatible goods, each pair occupies a line; and the second one contains M lists of goods to be shipped, each list occupies a line in the following format: 1K G[1] G[2] ... G[K] where K (≤1,000) is the number of goods and G[i]‘s are the IDs of the goods. To make it simple, each good is represented by a 5-digit ID number. All the numbers in a line are separated by spaces. Output Specification:For each shipping list, print in a line Yes if there are no incompatible goods in the list, or No if not. Sample Input:123456789106 320001 2000220003 2000420005 2000620003 2000120005 2000420004 200064 00001 20004 00002 200035 98823 20002 20003 20006 100103 12345 67890 23333 Sample Output:123NoYesYes 题目大意:氧化剂和易燃液体不能共存，给出冲突列表，问商品列表是否能共存 分析:刚开始的想法是记录哪些冲突，然后对给出的列表逐一判断各2个是否冲突，然后测试点2超时。。。然后换种思路，记录冲突，记录商品列表，对每一个商品，看与其冲突的商品是否存在于列表： map\&lt;int, vector\ &gt; e 来记录每一个商品的冲突列表（也可以vector\ e[100000]） 对每一个要解决的列表，用 exist[] （可以是 map 也可以是数组）记录某个id的商品是否存在，并将商品存在 goods[] （vector\）数组中，用于遍历 遍历 goods[]，针对每一个商品id（g1），遍历g1的冲突列表 e[g1][]，对每一个冲突商品 g2 判断其是否存在，即 exist[g2] 是否为真，若为真即可输出No C++:123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;int main() &#123; int n, m, k, g1, g2; map&lt;int, vector&lt;int&gt; &gt; e; scanf("%d%d", &amp;n, &amp;m); while(n--) &#123; scanf("%d%d", &amp;g1, &amp;g2); e[g1].push_back(g2); e[g2].push_back(g1); &#125; while (m--) &#123; bool exist[100005] = &#123;false&#125;; int goods[1005]; scanf("%d", &amp;k); for (int i = 0; i &lt; k; i++) &#123; scanf("%d", goods + i); exist[goods[i]] = true; &#125; bool flag = true; for (int i = 0; i &lt; k &amp;&amp; flag; i++) &#123; g1 = goods[i]; for (int j = 0; j &lt; e[g1].size() &amp;&amp; flag; j++) &#123; g2 = e[g1][j]; if (exist[g2]) flag = false; &#125; &#125; printf(flag ? "Yes\n" : "No\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
        <category>甲级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1152. Google Recruitment (20)]]></title>
    <url>%2FPAT%2F%E7%94%B2%E7%BA%A7%2F1152%2F</url>
    <content type="text"><![CDATA[In July 2004, Google posted on a giant billboard along Highway 101 in Silicon Valley (shown in the picture below) for recruitment. The content is super-simple, a URL consisting of the first 10-digit prime found in consecutive digits of the natural constant e. The person who could find this prime number could go to the next step in Google’s hiring process by visiting this website. The natural constant e is a well known transcendental number（超越数）. The first several digits are: e = 2.718281828459045235360287471352662497757247093699959574966967627724076630353547594571382178525166427427466391932003059921… where the 10 digits in bold are the answer to Google’s question. Now you are asked to solve a more general problem: find the first K-digit prime in consecutive digits of any given L-digit number. Input Specification:Each input file contains one test case. Each case first gives in a line two positive integers: L (≤ 1,000) and K (&lt; 10), which are the numbers of digits of the given number and the prime to be found, respectively. Then the L-digit number N is given in the next line. Output Specification:For each test case, print in a line the first K-digit prime in consecutive digits of N. If such a number does not exist, output 404 instead. Note: the leading zeroes must also be counted as part of the K digits. For example, to find the 4-digit prime in 200236, 0023 is a solution. However the first digit 2 must not be treated as a solution 0002 since the leading zeroes are not in the original number. Sample Input 1:1220 523654987725541023819 Sample Output 1:149877 Sample Input 2:1210 32468024680 Sample Output 2:1404 题目大意:给一个数，找到第一个 k 位素数 分析:从0位开始不断取出k位判断是不是素数，如果是就输出，数字前如果有 0，0 也要输出 C++:12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;bool isPrime(int n) &#123; if (n &lt; 2) return false; for (int i = 2; i * i &lt; n; i++) &#123; if (n % i == 0) return false; &#125; return true;&#125;int main() &#123; int l, k; string num; cin &gt;&gt; l &gt;&gt; k &gt;&gt; num; for (int i = 0; i + k &lt;= l; i++) &#123; if (isPrime(stoi(num.substr(i, k)))) &#123; cout &lt;&lt; num.substr(i, k); return 0; &#125; &#125; printf("404"); return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
        <category>甲级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1154. Vertex Coloring (25)]]></title>
    <url>%2FPAT%2F%E7%94%B2%E7%BA%A7%2F1154%2F</url>
    <content type="text"><![CDATA[A proper vertex coloring is a labeling of the graph’s vertices with colors such that no two vertices sharing the same edge have the same color. A coloring using at most k colors is called a (proper) k-coloring. Now you are supposed to tell if a given coloring is a proper k-coloring. Input Specification:Each input file contains one test case. For each case, the first line gives two positive integers N and M (both no more than 104), being the total numbers of vertices and edges, respectively. Then M lines follow, each describes an edge by giving the indices (from 0 to N−1) of the two ends of the edge. After the graph, a positive integer K (≤ 100) is given, which is the number of colorings you are supposed to check. Then K lines follow, each contains Ncolors which are represented by non-negative integers in the range of int. The i-th color is the color of the i-th vertex. Output Specification:For each coloring, print in a line k-coloring if it is a proper k-coloring for some positive k, or No if not. Sample Input:123456789101112131415161710 118 76 84 58 48 11 21 49 89 11 02 440 1 0 1 4 1 0 1 3 00 1 0 1 4 1 0 1 0 08 1 0 1 4 1 0 5 3 01 2 3 4 5 6 7 8 8 9 Sample Output:12344-coloringNo6-coloringNo 题目大意:给一张图，然后给 k 组不同的上色方案，如果图中存在连通的2点颜色相同，则输出no，否则输出颜色数 分析:vector\ g[10005] 来存储图，g[v1] 存储所有与v1相连同的点，保存单向图即可，因为是遍历边 c[10005] 存储每个点的颜色 set\ s 存储所有颜色，最后 s.size() 即为颜色数 遍历每个点的每条边，并判断颜色 C++:123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;vector&gt;using namespace std;int n, m;vector&lt;int&gt; g[10005];int main () &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt; m; i++) &#123; int v1, v2; scanf("%d%d", &amp;v1, &amp;v2); g[v1].push_back(v2); &#125; int k; scanf("%d", &amp;k); while (k--) &#123; int c[10005]; bool flag = true; set&lt;int&gt; s; for (int i = 0; i &lt; n; i++) &#123; scanf("%d", c + i); s.insert(c[i]); &#125; for (int i = 0; i &lt; n &amp;&amp; flag; i++) &#123; for (int j = 0; j &lt; g[i].size() &amp;&amp; flag; j++) &#123; if (c[i] == c[g[i][j]]) flag = false; &#125; &#125; if (flag) printf("%d-coloring\n", s.size()); else printf("No\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
        <category>甲级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1155. Heap Paths (30)]]></title>
    <url>%2FPAT%2F%E7%94%B2%E7%BA%A7%2F1155%2F</url>
    <content type="text"><![CDATA[In computer science, a heap is a specialized tree-based data structure that satisfies the heap property: if P is a parent node of C, then the key (the value) of P is either greater than or equal to (in a max heap) or less than or equal to (in a min heap) the key of C. A common implementation of a heap is the binary heap, in which the tree is a complete binary tree. (Quoted from Wikipedia at https://en.wikipedia.org/wiki/Heap_(data_structure)) One thing for sure is that all the keys along any path from the root to a leaf in a max/min heap must be in non-increasing/non-decreasing order. Your job is to check every path in a given complete binary tree, in order to tell if it is a heap or not. Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (1&lt;N≤1,000), the number of keys in the tree. Then the next line contains N distinct integer keys (all in the range of int), which gives the level order traversal sequence of a complete binary tree. Output Specification:For each given tree, first print all the paths from the root to the leaves. Each path occupies a line, with all the numbers separated by a space, and no extra space at the beginning or the end of the line. The paths must be printed in the following order: for each node in the tree, all the paths in its right subtree must be printed before those in its left subtree. Finally print in a line Max Heap if it is a max heap, or Min Heap for a min heap, or Not Heap if it is not a heap at all. Sample Input 1:12898 72 86 60 65 12 23 50 Sample Output 1:1234598 86 2398 86 1298 72 6598 72 60 50Max Heap Sample Input 2:1288 38 25 58 52 82 70 60 Sample Output 2:123458 25 708 25 828 38 528 38 58 60Min Heap Sample Input 3:12810 28 15 12 34 9 8 56 Sample Output 3:1234510 15 810 15 910 28 3410 28 12 56Not Heap 题目大意:给定一颗树的层序遍历结果，输出所有从根到叶子的路径（优先访问右子树），以及是否是最大堆、最小堆 分析:dfs，并判断左右子树与当前结点的大小来确定最大堆、最小堆；当左子树不存在时就是到叶子了 存储的时候，可以用数组存，从下标 1 开始存，这样当前结点 v 的左右子树分别为 v 2 和 v 2 + 1，v * 2 &gt; n 的时候就是到叶子结点了 C++:123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int n, a[1005];vector&lt;int&gt; path;bool isMax = true, isMin = true;void dfs(int v) &#123; path.push_back(a[v]); int child = v * 2 + 1; if (child &lt;= n) &#123; dfs(child); if (a[child] &lt; a[v]) isMin = false; else if (a[child] &gt; a[v]) isMax = false; &#125; child--; if (child &lt;= n) &#123; dfs(child); if (a[child] &lt; a[v]) isMin = false; else if (a[child] &gt; a[v]) isMax = false; &#125; else &#123; // 到叶结点了，输出 for (int i = 0; i &lt; path.size(); i++) &#123; printf("%d", path[i]); printf(i == path.size() - 1 ? "\n" : " "); &#125; &#125; path.pop_back();&#125;int main () &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", a + i); dfs(1); if (isMax) printf("Max Heap\n"); else if (isMin) printf("Min Heap\n"); else printf("Not Heap\n"); return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
        <category>甲级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1153. Decode Registration Card of PAT (25)]]></title>
    <url>%2FPAT%2F%E7%94%B2%E7%BA%A7%2F1153%2F</url>
    <content type="text"><![CDATA[A registration card number of PAT consists of 4 parts: the 1st letter represents the test level, namely, T for the top level, A for advance and B for basic; the 2nd - 4th digits are the test site number, ranged from 101 to 999; the 5th - 10th digits give the test date, in the form of yymmdd; finally the 11th - 13th digits are the testee’s number, ranged from 000 to 999. Now given a set of registration card numbers and the scores of the card owners, you are supposed to output the various statistics according to the given queries. Input Specification:Each input file contains one test case. For each case, the first line gives two positive integers N (≤104) and M (≤100), the numbers of cards and the queries, respectively. Then N lines follow, each gives a card number and the owner’s score (integer in [0,100]), separated by a space. After the info of testees, there are M lines, each gives a query in the format Type Term, where Type being 1 means to output all the testees on a given level, in non-increasing order of their scores. The corresponding Term will be the letter which specifies the level; Type being 2 means to output the total number of testees together with their total scores in a given site. The corresponding Term will then be the site number; Type being 3 means to output the total number of testees of every site for a given test date. The corresponding Term will then be the date, given in the same format as in the registration card. Output Specification:For each query, first print in a line Case #: input, where # is the index of the query case, starting from 1; and input is a copy of the corresponding input query. Then output as requested: for a type 1 query, the output format is the same as in input, that is, CardNumber Score. If there is a tie of the scores, output in increasing alphabetical order of their card numbers (uniqueness of the card numbers is guaranteed); for a type 2 query, output in the format Nt Ns where Nt is the total number of testees and Ns is their total score; for a type 3 query, output in the format Site Nt where Site is the site number and Nt is the total number of testees at Site. The output must be in non-increasing order of Nt‘s, or in increasing order of site numbers if there is a tie of Nt. If the result of a query is empty, simply print NA. Sample Input:123456789101112138 4B123180908127 99B102180908003 86A112180318002 98T107150310127 62A107180908108 100T123180908010 78B112160918035 88A107180908021 981 A2 1073 1809082 999 Sample Output:123456789101112Case 1: 1 AA107180908108 100A107180908021 98A112180318002 98Case 2: 2 1073 260Case 3: 3 180908107 2123 2102 1Case 4: 2 999NA 题目大意:先给 n 个准考证号和成绩，然后要求给出3种要求的统计结果： 输入考试类型，即准考证的第一位，输出相同类型的准考证号和分数，按分数从高到低，如果分数相同则按准考证号从小到大 给出 site，即准考证的第 2 - 4 位，输出相同 site 的人数和总分 给出 date，即准考证的第 5 - 10 位，输出相同 date ，不同的 site 及各 site 的人数 分析: 遍历将 id[0] == term[0] 的学生放入数组，再用 sort 排序输出 遍历当 id.substr(2, 3) == term 时，计数 + 1，分数加上去，最后输出 便利，用 unorder_map 存储各 site 的人数，再将 {site, num} 放入数组，sort 排序后输出 测试点3：用 map 会导致超时，换成 unordered_map 可过 C++:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;#include &lt;vector&gt;using namespace std;struct node &#123; string id; int value;&#125; s[10005];bool cmp(node &amp;s1, node &amp;s2) &#123; if (s1.value == s2.value) return s1.id &lt; s2.id; return s1.value &gt; s2.value;&#125;int main () &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) cin &gt;&gt; s[i].id &gt;&gt; s[i].value; for (int i = 1; i &lt;= m; i++) &#123; int type; string term; vector&lt;node&gt; ans; cin &gt;&gt; type &gt;&gt; term; printf("Case %d: %d %s\n", i, type, term.c_str()); if (type == 1) &#123; for (int i = 0; i &lt; n; i++) &#123; if (s[i].id[0] == term[0]) ans.push_back(&#123;s[i].id, s[i].value&#125;); &#125; &#125; else if (type == 2) &#123; int n_sum = 0, s_sum = 0; for (int i = 0; i &lt; n; i++) &#123; if (s[i].id.substr(1, 3) == term) &#123; ++n_sum; s_sum += s[i].value; &#125; &#125; if (n_sum == 0) printf("NA\n"); else printf("%d %d\n", n_sum, s_sum); &#125; else &#123; unordered_map&lt;string, int&gt; site; for (int i = 0; i &lt; n; i++) &#123; if (s[i].id.substr(4, 6) == term) ++site[s[i].id.substr(1, 3)]; &#125; for (auto it : site) ans.push_back(&#123;it.first, it.second&#125;); &#125; sort(ans.begin(), ans.end(), cmp); if (type != 2) &#123; if (ans.size() == 0) printf("NA\n"); else &#123; for (auto it : ans) printf("%s %d\n", it.id.c_str(), it.value); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
        <category>甲级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决Sublime的Package Control被墙]]></title>
    <url>%2FSublime%2F%E8%A7%A3%E5%86%B3Sublime%E7%9A%84Package-Control%E8%A2%AB%E5%A2%99%2F</url>
    <content type="text"><![CDATA[解决 Sublime 被墙导致的无法安装 Package Control 在 hosts 文件最后加上 150.116.34.243 sublime.wbond.net 关于 hosts 文件 mac 下，点击桌面上方的“前往”-&gt;“前往文件夹”（或者快捷键 Shift+Command+G） 输入 /private/etc 按回车 就可以看到里面的hosts文件了。拖一份副本放到桌面，直接右键选择“文本编辑”打开，修改，拖拽回原位置，替换。 引用自：https://www.cnblogs.com/xiaolu-web/p/4741527.html 安装 Package Control mac 下 Control+` 打开控制台 复制粘贴以下代码 1import urllib2,os; pf='Package Control.sublime-package'; ipp=sublime.installed_packages_path(); os.makedirs(ipp) if not os.path.exists(ipp) else None; urllib2.install_opener(urllib2.build_opener(urllib2.ProxyHandler())); open(os.path.join(ipp,pf),'wb').write(urllib2.urlopen('http://sublime.wbond.net/'+pf.replace(' ','%20')).read()); print 'Please restart Sublime Text to finish installation' 回车，等待完成 解决Package Control 被墙导致的无法安装插件 打开 Sublime Text &gt; Preferences &gt; Package Settings &gt; Package Control &gt; Settings - User 在文件下添加 1234"channels":[ "http://cst.stu.126.net/u/json/cms/channel_v3.json"], 如图 然后就可以愉快玩耍啦 mac 下可以通过 Command+Shift+P 输入 install 来安装插件]]></content>
      <categories>
        <category>Sublime</category>
      </categories>
      <tags>
        <tag>Sublime</tag>
      </tags>
  </entry>
</search>
